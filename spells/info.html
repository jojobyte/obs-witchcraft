<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Channel Info</title>
<style>
@import url(./styles/index.css);

textarea,
input {
  border: 0 solid transparent;
  background-color: black;
  color:ivory;
  box-sizing: border-box;
  font-size: 2rem;
  max-width: 98vw;
  width: 100%;
  padding: .5rem 1rem;
  margin: 1rem auto;
}
textarea {
  resize: vertical;
  min-height: 8rem;
  max-height: 20rem;
  height: 12rem;
}

button {
  padding: 1rem;
  background: darkorange;
}
button:hover {
  background: orange;
}
</style>
</head>
<body>

<h1>Channel Info</h1>
<div id="auth"></div>
<div id="controls"></div>

<script type="module" async>
const endpoint = {
  youtube: {
    base: 'https://youtube.googleapis.com/youtube/v3',
    auth: 'https://accounts.google.com/o/oauth2/v2/auth',
  },
  twitch: {
    base: 'https://api.twitch.tv/helix',
    auth: 'https://id.twitch.tv/oauth2/authorize',
  }
}

const scope = {
  youtube: {
    yt: 'https://www.googleapis.com/auth/youtube',
    ytfs: 'https://www.googleapis.com/auth/youtube.force-ssl',
    ytpca: 'https://www.googleapis.com/auth/youtubepartner-channel-audit',
  },
  twitch: {
    cmb: 'channel:manage:broadcast',
    ure: 'user:read:email',
    oid: 'openid',
  }
}

function parseJwt (token) {
  return token && JSON.parse(
    decodeURIComponent(
      window.atob(
        token?.split('.')?.[1]?.replace(/-/g, '+').replace(/_/g, '/')
      ).split('').map(
        c => '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2)
      ).join('')
    )
  )
}

function randStr (n) {
  return [...crypto.getRandomValues(new Uint8Array(n))]
  .map((x,i) => (
    i=x/255*61|0,
    String.fromCharCode(i+(i>9?i>35?61:55:48))
  )).join``
}

function hashToObject () {
  return Object.fromEntries(
    location.hash.substr(1).split('&').map(p => p.split('='))
  )
}

function storeCredentials (
  service, // youtube | twitch
) {
  // console.log('storeCredentials', location.hash, location.search)
  if (
    location.hash.indexOf('access_token') > -1 &&
    location.hash.indexOf('id_token') === -1
  ) {
    store[service] = {
      ...store[service],
      ...hashToObject()
    }
    localStorage.setItem(
      service,
      window.btoa(JSON.stringify(store[service]))
    )
    history.replaceState(null, '', 'info.html')
  }
}

function storeLogout (service) {
  store[service].access_token = ''
  localStorage.setItem(
    service,
    window.btoa(JSON.stringify(store[service]))
  )
  window.location.reload()
}

function handleHashChange () {
  storeCredentials('youtube')
  storeCredentials('twitch')
}

if (!localStorage.getItem('REDIRECT_URI')) {
  localStorage.setItem('REDIRECT_URI', 'https://localhost:8443/info.html')
}

let store = {}
store['youtube'] = localStorage.getItem('youtube')
store['youtube'] = store['youtube'] ? JSON.parse(window.atob(store['youtube'])) : ''
// console.log('localStorage youtube', store['yt'])

store['twitch'] = localStorage.getItem('twitch')
store['twitch'] = store['twitch'] ? JSON.parse(window.atob(store['twitch'])) : ''

let cfg = {
  youtube: {
    auth: {
      client_id: store['youtube']?.clientId || '',
      redirect_uri: localStorage.getItem('REDIRECT_URI'),
      response_type: 'token',
      scope: Object.values(scope.youtube).join` `,
      include_granted_scopes: 'true',
      state: randStr(40),
    },
    headers: {
      'Authorization': `Bearer ${store['youtube'].access_token}`,
      'Accept': 'application/json',
    }
  },
  twitch: {
    auth: {
      client_id: store['twitch']?.clientId || '',
      redirect_uri: localStorage.getItem('REDIRECT_URI'),
      response_type: 'token id_token',
      // scope: scope.twitch.cmb,
      scope: Object.values(scope.twitch).join` `,
      claims: JSON.stringify({
        "id_token": {
          "preferred_username": null,
          "picture": null,
        },
      }),
      state: randStr(40),
      nonce: randStr(40),
    },
    headers: {
      'Authorization': `Bearer ${store['twitch'].access_token}`,
      'Client-Id': store['twitch']?.clientId,
      'Content-Type': 'application/json',
    }
  }
}

let ytLiveBroadcasts
let ytLiveStreams
let ytActiveBroadcastData
let ytInsertLiveBroadcast
let twitchBroadcasterID
let twitchChannelInfo

let auth = document.querySelector('#auth')
let controls = document.querySelector('#controls')

if (!store['youtube']?.access_token) {
  storeCredentials('youtube')
}

if (!store['youtube']?.access_token) {
  if (cfg.youtube.auth.client_id !== '') {
    let ytAuthEndpoint = `${
      endpoint.youtube.auth
    }?${
      new URLSearchParams(cfg.youtube.auth)
    }`
    auth.insertAdjacentHTML(
      'beforeend',
      `<a class="btn youtube" href="${ytAuthEndpoint}">
        Connect with <i></i>
      </a>`
    )
  } else {
    controls.insertAdjacentHTML(
      'afterbegin',
      `
      <input name="api_key-yt" placeholder="YouTube API Key" />
      <input name="client_id-yt" placeholder="YouTube Client ID" />
      <button>Save YouTube Client ID</button>
      `
    )
  }
} else {
  ytLiveBroadcasts = await fetch(
    `${endpoint.youtube.base}/liveBroadcasts?part=snippet%2CcontentDetails%2Cstatus&broadcastType=all&mine=true`, // &broadcastStatus=active || upcoming
    {
      headers: {
        'Authorization': `Bearer ${store['youtube'].access_token}`,
        'Accept': 'application/json',
      },
    }
  )
  .then(res => res.status === 401 ? storeLogout('youtube') : res)
  .then(res => res.json())

  ytActiveBroadcastData = ytLiveBroadcasts?.items
    .filter(item => item.status.lifeCycleStatus !== 'complete')

  console.log('ytLiveBroadcasts', ytLiveBroadcasts, ytActiveBroadcastData)

  ytInsertLiveBroadcast = ytActiveBroadcastData?.find(
    cast => [
      'created',
      'testing'
    ].includes(cast.status.lifeCycleStatus) // created || live || complete
  )

  // console.log('TOP ytInsertLiveBroadcast', ytInsertLiveBroadcast)

  ytLiveStreams = await fetch(
    `${endpoint.youtube.base}/liveStreams?part=snippet%2Ccdn%2CcontentDetails%2Cstatus&mine=true`,
    {
      headers: {
        'Authorization': `Bearer ${store['youtube'].access_token}`,
        'Accept': 'application/json',
      },
    }
  )
  .then(res => res.status === 401 ? storeLogout('youtube') : res)
  .then(res => res.json())

  console.log('ytLiveStreams', ytLiveStreams)

  if (ytLiveBroadcasts.items.length > 0) {
    controls.insertAdjacentHTML(
      'beforeend',
      `
        <textarea name="stream_title-yt">${
          ytLiveBroadcasts.items?.[0]?.snippet?.title ||
          twitchChannelInfo?.data?.[0]?.title ||
          ''
        }</textarea>
        <button name="go_live-yt" class="btn youtube">Change <i></i> Title</button>
      `
    )
  } else {
    controls.insertAdjacentHTML(
      'beforeend',
      `
        <textarea name="stream_title-yt">${
          ytLiveBroadcasts.items?.[0]?.snippet?.title ||
          twitchChannelInfo?.data?.[0]?.title ||
          ''
        }</textarea>
        <button name="go_live-yt" class="btn youtube">Go Live on <i></i></button>
      `
    )
  }
}

if (!store['twitch']?.access_token) {
  storeCredentials('twitch')
}

if (!store['twitch']?.access_token) {
  if (cfg.twitch.auth.client_id !== '') {
    let twAuthEndpoint = `${endpoint.twitch.auth}?${new URLSearchParams(cfg.twitch.auth)}`
    auth.insertAdjacentHTML(
      'beforeend',
      `<a class="btn twitch" href="${twAuthEndpoint}"><i></i> Connect with Twitch</a>`
    )
  } else {
    controls.insertAdjacentHTML(
      'afterbegin',
      `<input name="client_id-tw" placeholder="Twitch Client ID" /><button>Save Twitch Client ID</button>`
    )
  }
} else {
  twitchBroadcasterID = parseJwt(store['twitch']?.id_token)?.sub
  twitchChannelInfo = await fetch(
    `${endpoint.twitch.base}/channels?broadcaster_id=${twitchBroadcasterID}`,
    {
      headers: {
        ...cfg.twitch.headers
      }
    }
  )
  .then((response) => response.json())
  if (twitchChannelInfo?.data?.length > 0) {
    controls.insertAdjacentHTML(
      'beforeend',
      `
        <textarea name="stream_title-tw">${
          twitchChannelInfo?.data?.[0]?.title ||
          ytLiveBroadcasts.items?.[0]?.snippet?.title ||
          ''
        }</textarea>
        <button name="go_live-tw" class="btn twitch"><i></i> Change Title</button>
      `
    )
  } else {
    controls.insertAdjacentHTML(
      'beforeend',
      `
        <textarea name="stream_title-tw">${
          twitchChannelInfo?.data?.[0]?.title ||
          ytLiveBroadcasts.items?.[0]?.snippet?.title ||
          ''
        }</textarea>
        <button name="go_live-tw" class="btn twitch">Go Live on <i></i></button>
      `
    )
  }
}

function handleClientId (previousElementSibling) {
  let [ prop, srv ] = previousElementSibling.name.split('-')
  let data = {
    clientId: previousElementSibling.value
  }
  if (srv === 'yt') {
    data['apiKey'] = previousElementSibling.previousElementSibling.value
  }
  let service = srv === 'tw' ? 'twitch' : 'youtube'
  let serviceData = srv === 'tw' ? twitch : youtube
  localStorage.setItem(
    service,
    window.btoa(JSON.stringify({
      ...serviceData,
      ...data
    }))
  )
  window.location.reload()
}

async function api (service, path, params, init) {
  return await fetch(
    `${endpoint[service].base}/${path}?${
      new URLSearchParams(params)
    }`,
    {
      headers: {
        ...cfg[service].headers,
      },
      ...init
    }
  )
  .then(res => res.status === 401 ? storeLogout(service) : res)
  .then(res => res.bodyUsed ? res.json() : res)
}

async function handleStreamTitle (previousElementSibling) {
  let [ prop, srv ] = previousElementSibling.name.split('-')
  if (srv === 'yt') {
    let broadcastParams = {
      part: ['snippet','contentDetails','status'],
    }
    if (!ytInsertLiveBroadcast) {
      ytInsertLiveBroadcast = ytActiveBroadcastData?.find(
        ({ status: { lifeCycleStatus, recordingStatus }}) =>
          lifeCycleStatus === 'live' && // created || live || complete
          recordingStatus === 'recording'
      )
      if (ytInsertLiveBroadcast) {
        let ytUpdateLiveBroadcast = await api(
          'youtube',
          'liveBroadcasts',
          broadcastParams,
          {
            method: 'PUT',
            body: JSON.stringify({
              id: ytInsertLiveBroadcast.id,
              contentDetails: {
                // enableClosedCaptions: true,
                enableContentEncryption: true,
                enableDvr: true,
                enableEmbed: true,
                recordFromStart: true,
                startWithSlate: true,
                monitorStream: {
                  enableMonitorStream: true,
                  broadcastStreamDelayMs: 5
                }
              },
              snippet: {
                title: previousElementSibling.value || '',
                scheduledStartTime: (new Date()).toISOString(),
              },
              status: {
                privacyStatus: 'public',
              }
            })
          }
        )
        window.location.reload()
        return
      }
    }
    if (!ytInsertLiveBroadcast) {
      // ytInsertLiveBroadcast = await fetch(
      //   `${endpoint.youtube.base}/liveBroadcasts?${
      //     new URLSearchParams(broadcastParams)
      //   }`,
      //   {
      //     method: 'POST',
      //     headers: {
      //       'Authorization': `Bearer ${store['youtube'].access_token}`,
      //       'Accept': 'application/json',
      //       'Content-Type': 'application/json',
      //     },
      //     body: JSON.stringify({
      //       snippet: {
      //         title: previousElementSibling.value || '',
      //         scheduledStartTime: (new Date()).toISOString(),
      //       },
      //       status: {
      //         privacyStatus: 'public',
      //       }
      //     })
      //   }
      // )
      // .then(res => res.status === 401 ? storeLogout('youtube') : res)
      // .then(res => res.json())
      ytInsertLiveBroadcast = await api(
        'youtube',
        'liveBroadcasts',
        broadcastParams,
        {
          method: 'POST',
          body: JSON.stringify({
            snippet: {
              title: previousElementSibling.value || '',
              scheduledStartTime: (new Date()).toISOString(),
            },
            status: {
              privacyStatus: 'public',
            }
          })
        }
      )
    }

    console.log('ytInsertLiveBroadcast', ytInsertLiveBroadcast)

    if (ytInsertLiveBroadcast.status.recordingStatus === 'notRecording') {
      let bindParams = {
        id: ytInsertLiveBroadcast.id,
        streamId: ytLiveStreams?.items?.[0]?.id,
        part: ['snippet'],
      }
      // let ytBindLiveBroadcast = await fetch(
      //   `${endpoint.youtube.base}/liveBroadcasts/bind?${
      //     new URLSearchParams(bindParams)
      //   }`,
      //   {
      //     method: 'POST',
      //     headers: {
      //       'Authorization': `Bearer ${store['youtube'].access_token}`,
      //       'Accept': 'application/json',
      //     },
      //   }
      // )
      let ytBindLiveBroadcast = await api(
        'youtube',
        'liveBroadcasts/bind',
        bindParams,
        {
          method: 'POST',
        }
      )

      console.log('ytBindLiveBroadcast', ytBindLiveBroadcast)

      let transitionParams = {
        id: ytInsertLiveBroadcast.id,
        part: ['snippet','status'],
        broadcastStatus: 'testing',
      }
      transitionParams.broadcastStatus = 'live'
      // transitionParams.broadcastStatus = 'complete'

      // let ytTransitionLiveBroadcast = await fetch(
      //   `${endpoint.youtube.base}/liveBroadcasts/transition?${
      //     new URLSearchParams(transitionParams)
      //   }`,
      //   {
      //     method: 'POST',
      //     headers: {
      //       'Authorization': `Bearer ${store['youtube'].access_token}`,
      //       'Accept': 'application/json',
      //     },
      //   }
      // )
      let ytTransitionLiveBroadcast = await api(
        'youtube',
        'liveBroadcasts/transition',
        transitionParams,
        {
          method: 'POST',
        }
      )

      console.log('ytTransitionLiveBroadcast', ytTransitionLiveBroadcast)
    }
  }
  if (srv === 'tw') {
    // await twitchChannelPatch()
    await api('twitch', 'channels', {
      broadcaster_id: twitchBroadcasterID
    }, {
      method: 'PATCH',
      body: JSON.stringify({
        title: previousElementSibling.value || ''
      })
    })
    // await fetch(
    //   `${endpoint.twitch.base}/channels?broadcaster_id=${twitchBroadcasterID}`,
    //   {
    //     method: 'PATCH',
    //     headers: {
    //       ...cfg.twitch.headers,
    //     },
    //     body: JSON.stringify({
    //       title: previousElementSibling.value || ''
    //     })
    //   }
    // )
  }
}

controls.addEventListener('click', async event => {
  if (event?.target) {
    const { tagName, previousElementSibling } = event.target
    if (tagName === 'BUTTON') {
      if (previousElementSibling) {
        let [ prop, srv ] = previousElementSibling.name.split('-')
        if (prop === 'client_id') {
          handleClientId(previousElementSibling)
        }
        if (prop === 'stream_title') {
          handleStreamTitle(previousElementSibling)
        }
      }
    }
  }
})

window.addEventListener('hashchange', handleHashChange);
</script>
</body>
</html>